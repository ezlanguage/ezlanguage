%{

#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <list>
#include <math.h> /* fmod , pow ... */
#include <cmath> /* fabs */
#include <string> /* to_string */

#include "../src/global.h"	 // we start from ../obj because it's important
#include "../src/main.cpp"	 // we start from ../obj because it's important
//#include "global.h"

#define YYERROR_VERBOSE
#define USE(VALUE) /*empty*/

extern FILE* yyin;
using namespace std;

 int yyparse (void);
 extern "C" int yylex();
 extern "C" void yyerror(const std::string&);
 extern int yylineno;

// Return the string value without quotation_marks
string delete_quote(string & str ){
  return str.substr(1,str.size()-2);
}

// Returns the argument value
string get_argument_value(string & str ){
  return str.substr(str.find_last_of("-")+1,str.size()-4);
}


%}


%token<numerical_value>	NUM_INTEGER			// ENTIER
%token<reel_value>	NUM_REAL			// REEL
%token<texte>	NAME RETOUR STRING STRING_PARAM		
%token<texte>	COMMA  DEGRE POURCENT DIESE POINT QUOTATION_MARKS		// Caractères
%token<texte> TYPE_INTEGER TYPE_REAL TYPE_STRING TYPE_BOOLEAN			// variables type
%token  EGAL NE LT LE GT GE PLUS MINUS MULT DIVISE
%token<texte>	LEFT_PARENTHESIS RIGHT_PARENTHESIS LEFT_ACCOLADE RIGHT_ACCOLADE LEFT_BRACKET RIGHT_BRACKET FIN BACK_LINE	// Special Characters
%token<texte> CONSTANT  VARIABLE  GLOBAL  IS  ARE SHARED          	      // variables declaration
%token IMPORT INCLUDE LIBRARY  EXTERN						 // importe module - code c++
%token IF THEN ELSE   						 // if else 
%token WHEN CASE  DEFAULT ENDWHEN				 // switch case ...
%token WHILE ENDWHILE							 // while .. do ..
%token REPEAT UNTIL ENDREPEAT 						 // do .. while ...
%token FOR IN DO STEP 
%token FUNCTION PROCEDURE RETURN	 				 // functions
%token PRINT
%token BEGINN END						       // can't use  'BEGIN'
%token END_OF_FILE
%token CLASS PROGRAM  DESTRUCT						//class
%token ARGUMENTS AS							// arguments	
%token REGEX SEARCH MATCH 					// Regular expression

%token LENGTH TOUPPERCASE TOLOWERCASE     
%token SUBSTRING SPLIT STRIP    
%token REPLACE CONTAINS     
%token FIND FINDFIRSTOF FINDLASTOF     

%token ARRAY VECTOR LIST SET MAP OF     

%token SIZE IS_EMPTY CLEAR FILL
%token RANDOMIZE COUNT MAX MIN SORT
%token SUM REMOVE RANGE PUT_FIRST PUT_LAST
%token REMOVE_LAST REMOVE_FIRST AVERAGE STORE
%token RESTORE FIRST LAST REMOVE_AT
%token PUT_AT INSERT EXIST

%left PLUS MINUS EGAL
%left NE LT LE GT GE MULT DIVISE AND OR XOR NOT MOD POW ABS OPERATOR		// Operators

%type<reel_value> expression single_expression designator statement_sequence function_call function_string map_declaration array_declaration vector_declaration list_declaration set_declaration    
%type<texte>  function procedure  string operators noms portee type  nbrOrName  params param_args param_type  


%start ROOT
%%

ROOT:
  next_line_null PROGRAM NAME  next_line  import  declaration_arguments declaration_class  statement_sequence END_OF_FILE { cout << "Fichier parsé." << endl; return 0;} 
;

// zero or several new lines
next_line_null:
| next_line {}
;

// one or several new lines
next_line:  
  BACK_LINE {}
| next_line BACK_LINE {}
;

// import modules ou librarys
import:
/* Nothing to import */
| import IMPORT NAME next_line    { cout << "importation du module " << $3 << endl; }
| import INCLUDE string next_line { cout << " inclusion de la bibliothèque " << delete_quote($3) << endl ; }
| import LIBRARY string next_line { cout << " inclusion de la LIBRARY " << delete_quote($3) << endl ; }
;

declaration_arguments:
/* No declarations */
| ARGUMENTS next_line param_args END next_endargument next_line {  cout << "delcaration des arguments " << endl;}
;

declaration_class: 
| declaration_class class next_line {} 
;

declaration_methods:
/* empty */
| declaration_methods function next_line {}  
| declaration_methods procedure next_line {}
;

param_args:
  NAME IS param_type AS STRING_PARAM next_line { cout << "parametre " << get_argument_value($5) << endl;} //ex: x is integer as "--x"
| NAME IS param_type AS STRING_PARAM next_line param_args { cout << "parametre " << get_argument_value($5) << endl; }
;

// Past arguments should be of only one of the following types: 
param_type:
  TYPE_INTEGER { $$ = $1; }
| TYPE_REAL   { $$ = $1; } 
| TYPE_STRING  {$$ = $1; } 
;

class:
CLASS NAME next_line begin  statement_sequence END next_endclass { cout << "declaration de la class" << $2 << endl; }
;

begin:
/* empty */
| BEGINN next_line { }
;

start_with_name:
   variable_without_scope  next_line { }
|  affectation  next_line { } 
|  function_call next_line {}
;

variable_without_scope:
     NAME IS  type affect  { cout << "Declaration de la variable1 " << $1 << endl; }
|    NAME noms ARE  type affect  { cout << "Declaration des variables1 "<< $1 << endl; }
|    NAME IS SHARED type affect  { cout << "Declaration de la variable1 " << $1 << endl; }
|    NAME noms ARE SHARED type affect  { cout << "Declaration des variables1 "<< $1 << endl; }
//|    NAME IS REGEX next_line { cout << " Declaration l'expression réguliere  " << $1 << endl; }
//|    NAME IS REGEX EGAL string next_line { cout << " Declaration  l'expression réguliere " << $1 << endl; }
|    declaration_construct  { cout << " declaration de contructeur " << endl ;}
;

variable_with_scope:
    portee NAME IS type affect next_line { cout << "= Declaration de la variable avec portee " << $2 << endl; }
|   portee NAME noms ARE type next_line { cout << "  Declaration des variables  avec portee "<< $2 << endl; }
|   portee NAME IS SHARED type affect next_line { cout << "= Declaration de la variable avec portee " << $2 << endl; }
|   portee NAME noms ARE SHARED type next_line { cout << "  Declaration des variables  avec portee "<< $2 << endl; }
/* regular expression */
|    portee NAME IS REGEX next_line { cout << " Declaration l'expression réguliere  " << $2 << endl; }
|    portee NAME IS REGEX EGAL string next_line { cout << " Declaration  l'expression réguliere " << $2 << endl; }
;

variable_constant:
     CONSTANT NAME IS  type affect  { cout << "Declaration de la variable constante " << $1 << endl; }
|    CONSTANT NAME noms ARE  type affect  { cout << "Declaration des variables constante "<< $1 << endl; }
|    CONSTANT NAME IS SHARED type affect  { cout << "Declaration de la variable constante " << $1 << endl; }
|    CONSTANT NAME noms ARE SHARED type affect  { cout << "Declaration des variables constante "<< $1 << endl; }
/* regular expression */
|    CONSTANT NAME IS REGEX next_line { cout << " Declaration l'expression réguliere  " << $2 << endl; }
|    CONSTANT NAME IS REGEX EGAL string next_line { cout << " Declaration  l'expression réguliere " << $2 << endl; }
;

declaration_construct:
   NAME IS NAME {}  // ex: c is Maclasse
|  NAME IS NAME LEFT_PARENTHESIS class_liste_argument RIGHT_PARENTHESIS {} // c is MaClass(val1,va2)
|  NAME IS NAME LEFT_PARENTHESIS class_liste_argument_with_assignment RIGHT_PARENTHESIS {} // p is Person(nom="nom")
;

affect:
/* No assigned value */
| EGAL expression { }
| EGAL string { }
;

class_liste_argument:
  string { }
| NUM_INTEGER  {}
| NUM_REAL  {}
| NAME  {}
| string COMMA class_liste_argument  { }
| NUM_INTEGER COMMA class_liste_argument  {}
| NUM_REAL COMMA class_liste_argument  {}
| NAME COMMA class_liste_argument {} 
;

class_liste_argument_with_assignment:
  NAME EGAL string { }
| NAME EGAL NUM_INTEGER   {}
| NAME EGAL NUM_REAL  {}
| NAME EGAL NAME  {}
| NAME EGAL string COMMA class_liste_argument_with_assignment  { }
| NAME EGAL NUM_INTEGER COMMA class_liste_argument_with_assignment  {}
| NAME EGAL NUM_REAL COMMA class_liste_argument_with_assignment  {}
| NAME EGAL NAME COMMA class_liste_argument_with_assignment {} 
;


function:
SHARED FUNCTION NAME LEFT_PARENTHESIS liste_argument RIGHT_PARENTHESIS RETURN type next_line  begin   statement_sequence RETURN expression next_line END next_endfunction { cout << "declaration de la fonction" << $3 << endl;}
| FUNCTION NAME LEFT_PARENTHESIS liste_argument RIGHT_PARENTHESIS RETURN type next_line  begin   statement_sequence RETURN expression next_line END next_endfunction { cout << "declaration de la fonction" << $2 << endl;}
| FUNCTION NAME LEFT_PARENTHESIS liste_argument RIGHT_PARENTHESIS IS EXTERN NAME { cout << "declaration d'une fonction externe " << endl;  }
;

procedure:
  PROCEDURE NAME LEFT_PARENTHESIS liste_argument RIGHT_PARENTHESIS next_line begin statement_sequence END next_endprocedure {cout << "Declaration de la procedure " << $2 << endl;}
| PROCEDURE PRINT LEFT_PARENTHESIS  RIGHT_PARENTHESIS next_line begin statement_sequence END next_endprocedure {cout << "Surcharge de la methode d'affichage \"print\" "  << endl;}
| SHARED PROCEDURE NAME LEFT_PARENTHESIS liste_argument RIGHT_PARENTHESIS next_line begin  statement_sequence END next_endprocedure {cout << "Declaration de la procedure " << $3 << endl;}
| SHARED PROCEDURE PRINT LEFT_PARENTHESIS  RIGHT_PARENTHESIS next_line begin statement_sequence END next_endprocedure {cout << "Surcharge de la methode d'affichage \"print\" "  << endl;}
;

next_endclass:
| CLASS {}
;


next_endprocedure:
/* emplty */
| PROCEDURE {}
;

next_endfunction:
/* empty */
| FUNCTION {}
;

next_endif:
/* empty */
| IF {}
;

next_endwhen:
/*empty */
| WHEN  {}
;

next_endcase:
/* empty*/
| CASE {}
;

next_endwhile:
/* empty */
|  WHILE {}
;

next_endfor:
/*emtpy */
| FOR
;

next_endrepeat:
/* empty */
| REPEAT {}
;

next_enddestruct:
/* empty */
| DESTRUCT {}
;

next_endargument:
/* empty */
| ARGUMENTS {}
;


statement_sequence:
 /*empty */
| statement_sequence statement{ }
;

liste_argument:
 // No argument
 | NAME IS type { }
 | NAME IS type COMMA liste_argument { }
 | NAME noms ARE type {}
;

destruct:
  DESTRUCT next_line statement_sequence  END next_enddestruct { cout << "destructeur " << endl;}
;

overloading:
  OPERATOR operators LEFT_PARENTHESIS NAME IS NAME RIGHT_PARENTHESIS RETURN type next_line statement_sequence END { cout << "operateur " <<  $2 << endl; }
;

operators:
 EGAL EGAL { $$ = "==";}
|  EGAL   { $$ = "=";}
|  NE  { $$= "!="; }
|  LT  { $$ =  "<"; }
|  LE  { $$ = "<=";}
|  GT  { $$ = ">";}
|  GE  { $$ = ">=";}
|  PLUS   {$$ ="+";}
|  MINUS  { $$ = "-";}
|  MULT   {$$ = "*";}
|  DIVISE { $$ =  "/";}
;

// 		---------------------------------------------------------------------
statement:
  next_line
| variable_with_scope  {} 
| variable_constant {}
| start_with_name {}  // variables - functions - construct
| declaration_methods {}
| destruct {}
| printing {}
| overloading {}
| IF expression THEN next_line statement_sequence ELSE next_line statement_sequence END next_endif { printf("SI_SINON_ALORS \n"); }
| IF expression THEN next_line statement_sequence  END next_endif { printf("SI   ALORS \n"); }
| WHEN expression IS next_line whenbody whendefault END next_endwhen {  printf("when .. case .. \n"); }
| WHILE expression DO  statement_sequence END next_endwhile { printf("WHILE .. DO .. \n"); }
| REPEAT statement_sequence UNTIL next_line expression next_line END next_endrepeat{ printf("REPEAT .. UNTIL .. \n"); }
| for {}
;
// 		---------------------------------------------------------------------

/*else_body:
   ELSE next_line statement_sequence   { cout << "else " << endl; }
|  ELSE next_line statement_sequence  else_body  { cout << "else " << endl;}
;*/

affectation:
  NAME EGAL expression { cout << "Affectation name " <<  endl; }
| NAME POINT NAME EGAL expression { cout << "Affectation name.name " <<  endl; }
| NAME PLUS PLUS { cout << "Affectation ++" <<  endl; }
| NAME MINUS MINUS {  cout << "Affectation --" <<  endl; }
| PLUS PLUS NAME  { cout << "++ Affectation " <<  endl; }
| MINUS MINUS NAME  { cout << "-- Affectation " <<  endl;  }
;

printing :
PRINT expressions  next_line { }
;

expressions:
  expression   { cout <<"affichage  : " <<  $1  << endl; }
| string    {   cout << "affichage  : " << delete_quote($1) << endl; }
| expression COMMA expressions { cout <<"affichage  : " <<  $1 << endl; }
| string  COMMA expressions {   cout << "affichage : " << delete_quote($1) << endl; }
;

for :
  FOR NAME IN expression POINT POINT expression DO next_line statement_sequence END next_endfor next_line{ printf("FOR .. IN ... \n");}
| FOR NAME IN expression POINT POINT expression STEP nbrOrName  DO next_line statement_sequence END next_endfor next_line { printf("FOR .. IN ... \n");}
| FOR NAME IS type IN expression POINT POINT expression DO next_line statement_sequence END next_endfor next_line { printf("FOR .. IN ... \n");}
| FOR NAME IS type IN expression POINT POINT expression STEP nbrOrName  DO next_line statement_sequence END next_endfor next_line{ printf("FOR .. IN ... \n");}
;


function_call : 
  NAME POINT simple_function {}
| function_call POINT simple_function {}
| simple_function { }
| NAME POINT NAME { }  
| function_string { $$ = $1;}
| function_regex { }
| containers_methods { }
;

simple_function:
   // function without parametre
  NAME LEFT_PARENTHESIS RIGHT_PARENTHESIS {} 
    // function wit parametre
| NAME LEFT_PARENTHESIS params RIGHT_PARENTHESIS {} 
;

params:
  expression { $$ = $1;}
| expression COMMA params { $$ = $1 ;}
;

//    -----------------------------REGEX METHODS-----------------------------------------
function_regex:
  NAME POINT MATCH  LEFT_PARENTHESIS strOrName RIGHT_PARENTHESIS { cout << " expression régulière MATCH " << endl ;}
| NAME POINT SEARCH  LEFT_PARENTHESIS strOrName COMMA strOrName RIGHT_PARENTHESIS { cout << " expression régulière SEARCH " << endl ;}
|   NAME POINT REPLACE  LEFT_PARENTHESIS strOrName COMMA strOrName RIGHT_PARENTHESIS { cout << " expression régulière REPLACE " << endl ;}
;

strOrName:
  string { }
| NAME { } 
;

//    -----------------------------STRING METHODS----------------------------------------
function_string : 
NAME POINT LENGTH LEFT_PARENTHESIS RIGHT_PARENTHESIS { printf("lENGTH() called \n"); }
| NAME POINT TOUPPERCASE LEFT_PARENTHESIS RIGHT_PARENTHESIS { printf("toUpperCase() called \n"); }
| NAME POINT TOLOWERCASE LEFT_PARENTHESIS RIGHT_PARENTHESIS { printf("toLowerCase() called \n"); }
| NAME POINT SUBSTRING LEFT_PARENTHESIS NUM_INTEGER RIGHT_PARENTHESIS { printf("SUBSTRING(int) called \n"); }
| NAME POINT SUBSTRING LEFT_PARENTHESIS NAME RIGHT_PARENTHESIS { printf("SUBSTRING(int) called \n"); }
| NAME POINT SUBSTRING LEFT_PARENTHESIS NUM_INTEGER COMMA NUM_INTEGER RIGHT_PARENTHESIS { printf("SUBSTRING(int,int) called \n"); }
| NAME POINT SUBSTRING LEFT_PARENTHESIS NAME COMMA NUM_INTEGER RIGHT_PARENTHESIS { printf("SUBSTRING(int,int) called \n"); }
| NAME POINT SUBSTRING LEFT_PARENTHESIS NUM_INTEGER COMMA NAME RIGHT_PARENTHESIS { printf("SUBSTRING(int,int) called \n"); }
| NAME POINT SUBSTRING LEFT_PARENTHESIS NAME COMMA NAME RIGHT_PARENTHESIS { printf("SUBSTRING(int,int) called \n"); }
| NAME POINT SPLIT LEFT_PARENTHESIS STRING RIGHT_PARENTHESIS { printf("SPLIT(\"str\") called \n"); }
| NAME POINT STRIP LEFT_PARENTHESIS RIGHT_PARENTHESIS { printf("strip() called \n"); }
| NAME POINT STRIP LEFT_PARENTHESIS STRING RIGHT_PARENTHESIS { printf("strip(\"str\") called \n"); }
| NAME POINT REPLACE LEFT_PARENTHESIS STRING COMMA STRING RIGHT_PARENTHESIS { printf("replace(\"str\",\"str\") called \n"); }
| NAME POINT CONTAINS LEFT_PARENTHESIS STRING RIGHT_PARENTHESIS { printf("contain(\"str\") called \n"); }
| NAME POINT FIND LEFT_PARENTHESIS STRING RIGHT_PARENTHESIS { printf("find(\"str\") called \n"); }
| NAME POINT FINDFIRSTOF LEFT_PARENTHESIS STRING RIGHT_PARENTHESIS { printf("findFirstOF(\"str\") called \n"); }
| NAME POINT FINDLASTOF LEFT_PARENTHESIS STRING RIGHT_PARENTHESIS { printf("findFirstOF(\"str\") called \n"); }
;


//    -----------------------------array Declaration----------------------------------------
array_declaration :
portee NAME IS ARRAY LEFT_BRACKET NUM_INTEGER POINT POINT NUM_INTEGER RIGHT_BRACKET OF type { printf("array declaration with lower and upper bound \n"); }
| portee NAME IS ARRAY LEFT_BRACKET NUM_INTEGER POINT POINT NAME RIGHT_BRACKET OF type { printf("array declaration with lower and upper bound \n"); }
| portee NAME IS ARRAY LEFT_BRACKET NAME POINT POINT NUM_INTEGER RIGHT_BRACKET OF type { printf("array declaration with lower and upper bound\n"); }
| portee NAME IS ARRAY LEFT_BRACKET NUM_INTEGER RIGHT_BRACKET OF type { printf("array declaration with size \n"); }
| portee NAME IS ARRAY LEFT_BRACKET NAME RIGHT_BRACKET OF type { printf("array declaration with size \n"); }
| portee NAME IS ARRAY LEFT_BRACKET NUM_INTEGER RIGHT_BRACKET OF type EGAL LEFT_ACCOLADE noms RIGHT_ACCOLADE { printf("array declaration  with initializer list \n"); }
| portee NAME IS ARRAY LEFT_BRACKET NAME RIGHT_BRACKET OF type EGAL LEFT_ACCOLADE noms RIGHT_ACCOLADE { printf("array declaration with size with initializer list \n"); }
;

//    -----------------------------vector Declaration----------------------------------------
vector_declaration : 
portee NAME IS VECTOR OF type { printf("vector declaration  \n"); }
| portee NAME IS VECTOR LEFT_BRACKET NUM_INTEGER RIGHT_BRACKET OF type { printf("vector declaration with size \n"); }
| portee NAME IS VECTOR LEFT_BRACKET NAME RIGHT_BRACKET OF type { printf("vector declaration with size \n"); }
| portee NAME IS VECTOR OF type EGAL LEFT_ACCOLADE noms RIGHT_ACCOLADE { printf("vector declaration with initializer list \n"); }
;

//    -----------------------------list Declaration----------------------------------------
list_declaration : 
portee NAME IS LIST OF type { printf("list declaration  \n"); }
| portee NAME IS LIST OF type EGAL LEFT_ACCOLADE noms RIGHT_ACCOLADE { printf("list declaration with initializer list \n"); }
;

//    -----------------------------set Declaration----------------------------------------
set_declaration : 
portee NAME IS SET OF type { printf("set declaration  \n"); }
| portee NAME IS SET LEFT_BRACKET NUM_INTEGER RIGHT_BRACKET OF type { printf("set declaration with size \n"); }
| portee NAME IS SET LEFT_BRACKET NAME RIGHT_BRACKET OF type { printf("set declaration with size \n"); }
| portee NAME IS SET OF type EGAL LEFT_ACCOLADE noms RIGHT_ACCOLADE { printf("set declaration with initializer list \n"); }
;

//    -----------------------------map Declaration----------------------------------------
map_declaration : 
portee NAME IS MAP OF LT type COMMA type GT { printf("map declaration  \n"); }
| map_declaration EGAL LEFT_ACCOLADE noms RIGHT_ACCOLADE { printf("map declaration with initializer list \n"); }
;


//    ---------------------------------------------------------------------------------------
//    -----------------------------Containers Methods----------------------------------------
//
//    ---------------------------------------------------------------------------------------
//    -----------------------------Container's methods---------------------------------------
//    ---------------------------------------------------------------------------------------

containers_methods : 
NAME POINT SIZE LEFT_PARENTHESIS RIGHT_PARENTHESIS { printf("utilisation de la méthode size  \n"); }
| NAME POINT IS_EMPTY LEFT_PARENTHESIS RIGHT_PARENTHESIS { printf("utilisation de la méthode size  \n"); }
| NAME POINT CLEAR LEFT_PARENTHESIS RIGHT_PARENTHESIS { printf("utilisation de la méthode size  \n"); }
| NAME POINT PRINT LEFT_PARENTHESIS RIGHT_PARENTHESIS { printf("utilisation de la méthode size  \n"); }
| NAME POINT FILL LEFT_PARENTHESIS nbrOrName RIGHT_PARENTHESIS { printf("fill(value) called \n"); }
| NAME POINT RANDOMIZE LEFT_PARENTHESIS nbrOrName COMMA nbrOrName RIGHT_PARENTHESIS { printf("randomize(min,max) called \n"); }
| NAME POINT MAX LEFT_PARENTHESIS RIGHT_PARENTHESIS { printf("MAX() called \n"); }
| NAME POINT MAX LEFT_PARENTHESIS nbrOrName RIGHT_PARENTHESIS { printf("MAX(attr) called \n"); }
| NAME POINT MIN LEFT_PARENTHESIS RIGHT_PARENTHESIS { printf("MIN() called \n"); }
| NAME POINT MIN LEFT_PARENTHESIS nbrOrName RIGHT_PARENTHESIS { printf("MIN(attr) called \n"); }
| NAME POINT SORT LEFT_PARENTHESIS RIGHT_PARENTHESIS { printf("SORT() called \n"); }
| NAME POINT SORT LEFT_PARENTHESIS nbrOrName RIGHT_PARENTHESIS { printf("SORT(attr) called \n"); }
| NAME POINT SUM LEFT_PARENTHESIS RIGHT_PARENTHESIS { printf("SUM() called \n"); }
| NAME POINT SUM LEFT_PARENTHESIS nbrOrName RIGHT_PARENTHESIS { printf("SUM(attr) called \n"); }
| NAME POINT COUNT LEFT_PARENTHESIS nbrOrName RIGHT_PARENTHESIS { printf("COUNT(val) called \n"); }
| NAME POINT REMOVE LEFT_PARENTHESIS nbrOrName RIGHT_PARENTHESIS { printf("remove(val) called \n"); }
| NAME POINT RANGE LEFT_PARENTHESIS RIGHT_PARENTHESIS { printf("range() called \n"); }
| NAME POINT FIND LEFT_PARENTHESIS nbrOrName RIGHT_PARENTHESIS { printf("find(val) called \n"); }
| NAME POINT FIND LEFT_PARENTHESIS NAME COMMA nbrOrName RIGHT_PARENTHESIS { printf("find(attr,val) called \n"); }
| NAME POINT COUNT LEFT_PARENTHESIS NAME COMMA nbrOrName RIGHT_PARENTHESIS { printf("COUNT(attr,val) called \n"); }
| NAME POINT PUT_FIRST LEFT_PARENTHESIS nbrOrName RIGHT_PARENTHESIS { printf("PUT_FIRST(elem) called \n"); }
| NAME POINT PUT_LAST LEFT_PARENTHESIS nbrOrName RIGHT_PARENTHESIS { printf("PUT_Last(elem) called \n"); }
| NAME POINT REMOVE_LAST LEFT_PARENTHESIS RIGHT_PARENTHESIS { printf("remove_Last() called \n"); }
| NAME POINT REMOVE_FIRST LEFT_PARENTHESIS RIGHT_PARENTHESIS { printf("remove_Last() called \n"); }
| NAME POINT AVERAGE LEFT_PARENTHESIS RIGHT_PARENTHESIS { printf("average() called \n"); }
| NAME POINT AVERAGE LEFT_PARENTHESIS nbrOrName RIGHT_PARENTHESIS { printf("average(attr) called \n"); }
| NAME POINT STORE LEFT_PARENTHESIS NAME RIGHT_PARENTHESIS { printf("STORE(val) called \n"); }
| NAME POINT RESTORE LEFT_PARENTHESIS NAME RIGHT_PARENTHESIS { printf("RESTORE(val) called \n"); }
| NAME POINT FIRST LEFT_PARENTHESIS RIGHT_PARENTHESIS { printf("first() called \n"); }
| NAME POINT LAST LEFT_PARENTHESIS RIGHT_PARENTHESIS { printf("last() called \n"); }
| NAME POINT REMOVE_AT LEFT_PARENTHESIS NUM_INTEGER RIGHT_PARENTHESIS { printf("REMOVE_AT(pos) called \n"); }
| NAME POINT PUT_AT LEFT_PARENTHESIS NUM_INTEGER COMMA nbrOrName RIGHT_PARENTHESIS { printf("put_at(pos, val) called \n"); }
| NAME POINT INSERT LEFT_PARENTHESIS RIGHT_PARENTHESIS { printf("insert() called \n"); }
| NAME POINT INSERT LEFT_PARENTHESIS nbrOrName COMMA nbrOrName RIGHT_PARENTHESIS { printf("insert(key,val called \n"); }
| NAME POINT EXIST LEFT_PARENTHESIS nbrOrName RIGHT_PARENTHESIS { printf("insert() called \n"); }
;



nbrOrName:
  NUM_INTEGER  { $$ = to_string($1);}
| NUM_REAL {$$ = $1; }
| NAME {$$ = $1;}
;

portee: 
  VARIABLE {$$ = $1;}
| GLOBAL {$$ = $1;}
;

type:
  TYPE_INTEGER { $$ = $1; }
| TYPE_REAL   { $$ = $1; } 
| TYPE_STRING  {$$ = $1; } 
| TYPE_BOOLEAN  {$$ = $1; }
;


noms:
  NAME {$$ = $1;}
| COMMA NAME noms {$$ = $1;}
| COMMA NAME {$$ = $1;}

;

whenbody: /* whenbody can't be empty */
  CASE  expression next_line statement_sequence  END next_endcase next_line  { cout << "case body" << endl; }
| CASE  expression next_line statement_sequence  END next_endcase next_line whenbody { cout << "case body" << endl;}
;

whendefault: /* May not be specified */
| DEFAULT next_line statement_sequence  END next_endcase next_line{}
;

string :
 STRING  { $$= $1;}
;

//For  those  rules in comment , the corresponding definition must be written by the C++ team because their (rules) have not effect.
expression:
  single_expression { $1 = $1 ;}  
| expression EGAL EGAL expression { /*$1 == $4;*/ } 
| expression NE expression {/* $1 != $3; */}
| expression LT expression { /*$1 < $3;*/ }
| expression LE expression {/* $1 <= $3;*/ }
| expression GT expression {/* $1 > $3 ;*/}
| expression GE expression { /*$1 >= $3 ;*/}
| expression PLUS expression {$$ = $1 + $3; }
| expression MINUS expression { $$ = $1 - $3; }
| expression MULT expression {$$ = $1 * $3 ;}
| expression DIVISE expression { $$ =  $1 / $3 ;}
| expression AND AND expression {/* $1 && $4;  */ }
| expression OR OR expression {/* $1 || $4 ; */ }
;

single_expression:   
  PLUS single_expression { $$ = $2;  }
| single_expression XOR single_expression { /* $1^$3 ; */}
| NOT single_expression { $$ = !$2 ; }
| single_expression MOD single_expression { $$ =  fmod($1,$3); }
| single_expression POW single_expression { $$ = pow($1, $3); }
| ABS single_expression { $$ = fabs($2);}
| LEFT_PARENTHESIS expression RIGHT_PARENTHESIS { $$ = $2 ;}
| NUM_REAL { $$ = $1;} //real
| NUM_INTEGER { $$ = $1;  }  // integer
| designator { $$ = $1;}
| function_call {  $$ = $1;}
| map_declaration {$$ = $1;}
| array_declaration { $$ = $1;}
| vector_declaration   {$$ = $1;}
| list_declaration  { $$ = $1;}
| set_declaration {$$ = $1;}
;

designator:
  NAME { /* $$ = value of $1*/  }

;

%%

void yyerror(const std::string& mess){
    std::cout << "Erreur trouvée à la ligne " << yylineno << " :  "<<mess  << std::endl;
}
